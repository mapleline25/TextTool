using Microsoft.CodeAnalysis.CSharp;
using System;
using static TextTool.SourceGenerators.Helpers.Resources;
using TextTool.SourceGenerators.Models;
using CommunityToolkit.Mvvm.SourceGenerators.Helpers;

namespace TextTool.SourceGenerators.Helpers;
internal ref struct SourceBuilder
{
    private const string _IndentString = "    ";
    private const string _OpenString = "{";
    private const string _CloseString = "}";
    private readonly ArrayBufferWriter<char> _writer = new();
    public int _indent = 0;
    private bool _indented;

    public SourceBuilder()
    {
    }

    public void AppendSourceHeader()
    {
        AppendLine("""
//<auto-generated/>
#nullable enable
#pragma warning disable
""");
    }

    public void AppendDeclarationHeader()
    {
        AppendLine($$"""
{{HeaderAttributeResource.GeneratedCodeAttributeContent}}
{{HeaderAttributeResource.DebuggerNonUserCodeAttributeContent}}
{{HeaderAttributeResource.ExcludeFromCodeCoverageAttributeContent}}
""");
    }

    public void BeginHierarchyBlocks(ReadOnlySpan<char> nameSpace, ReadOnlySpan<HierarchyTypeInfo> types, bool reverseTypesAppendOrder = true)
    {
        if (!nameSpace.IsEmpty)
        {
            BeginNamespaceBlock(nameSpace);
        }

        if (reverseTypesAppendOrder)
        {
            for (int i = types.Length - 1; i >= 0; i--)
            {
                BeginHierarchyTypeBlock(types[i]);
            }
        }
        else
        {
            for (int i = 0; i < types.Length; i++)
            {
                BeginHierarchyTypeBlock(types[i]);
            }
        }
    }

    public void BeginNamespaceBlock(ReadOnlySpan<char> nameSpace)
    {
        Append("namespace ");
        AppendLine(nameSpace);
        BeginBlock();
    }

    public void BeginHierarchyTypeBlock(HierarchyTypeInfo info)
    {
        string keyword = info.KeywordKind switch
        {
            SyntaxKind.ClassKeyword => "class",
            SyntaxKind.StructKeyword => "struct",
            SyntaxKind.RecordKeyword => "record",
            _ => "interface",
        };

        Append("partial ");
        Append(keyword);
        Append(" ");
        AppendLine(info.Name);
        BeginBlock();
    }

    public void Append(ReadOnlySpan<char> chars)
    {
        Write(chars);
    }

    public void AppendLine(ReadOnlySpan<char> chars)
    {
        Write(chars);
        WriteNewLine();
    }

    public void AppendLine()
    {
        WriteNewLine();
    }

    public void BeginBlock()
    {
        AppendLine(_OpenString);
        _indent++;
    }

    public void EndBlock()
    {
        if (_indent-- > 0)
        {
            AppendLine(_CloseString);
        }
    }

    public void EndAllBlocks()
    {
        while (_indent-- > 0)
        {
            AppendLine(_CloseString);
        }
    }

    public override string ToString()
    {
        return _writer.WrittenSpan.ToString();
    }

    public void Reset()
    {
        _writer.ResetWrittenCount();
    }

    public void Dispose()
    {
        _writer.ResetWrittenCount();
        _writer.Dispose();
    }

    private void Write(ReadOnlySpan<char> chars)
    {
        if (chars.IsEmpty)
        {
            return;
        }

        while (true)
        {
            CheckIndents();

            int index = chars.IndexOfAny('\r', '\n');

            if (index != -1)
            {
                _writer.Write(chars.Slice(0, index));
                WriteNewLine();

                if (chars[index] == '\r')
                {
                    int next = index + 1;
                    if (next < chars.Length && chars[next] == '\n')
                    {
                        index++;
                    }
                }
                index++;

                chars = chars.Slice(index);
            }
            else
            {
                _writer.Write(chars);
                break;
            }
        }
    }

    private void WriteNewLine()
    {
        _writer.Write(SystemResource.NewLine);
        _indented = false;
    }

    private void CheckIndents()
    {
        if (_indented)
        {
            return;
        }
        
        ReadOnlySpan<char> tab = _IndentString;
        for (int i = 0; i < _indent; i++)
        {
            _writer.Write(tab);
        }

        _indented = true;
    }
}
